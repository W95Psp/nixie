#!/usr/bin/env sh
# vim: ts=2 sw=2
# Nix-wrap (c) Karim Vergnes <me@thesola.io>
# Licensed under GNU GPLv2
# Required commands:
#  - sed
#  - tar (with gzip support)
#  - rm, mv, tail, uname, env, chmod, mkdir (coreutils)
#  - git
#  - kill
#  - one of wget, curl or python3 (with SSL support)
#  - sh with source and declare -a
# A C++ toolchain is also required for building Nix locally.

SYSTEM="$(uname -s).$(uname -m)"
REPO_ROOT="$(git rev-parse --show-toplevel)"
THIS_SCRIPT="$(readlink -e $0)"
PWD_SAVE=$PWD

##### UTILITY FUNCTIONS #####

# Output an error message to stderr then nuke ourselves
_bail() {
  >&2 echo $@
  >&2 echo "This script can be rebuilt using nix-wrap"
  kill -ABRT $$
}

# Pull a file or directory from the resource tarball linked into this
# script. Useful for semi-offline or completely offline operation.
_untar() {
  {
  sed -n '/^-----BEGIN ARCHIVE SECTION-----/,$p' "$THIS_SCRIPT" \
      | tail -n +2                                              \
      | gzip -d -c 2>/dev/null
  if ! ([[ $? == 2 ]] || [[ $? == 0 ]])
  then
    # The resource tarball is required since it contains the feature
    # attributes for this script. We bail out since there is no
    # situation where tar failing would bode well.
    _bail "Could not find or decompress resource archive."
  fi
  } | tar -x "$@"
}

# Best-attempt script for downloading files. We first try wget, then cURL,
# then Python 3.
_dl() {
  if which wget >&/dev/null
  then
    wget "$1" -O"$2" || { rm "$2"; return 1; }
  elif which curl >&/dev/null
  then
    curl -f -L "$1" -o "$2"
  elif which python3 >&/dev/null
  then
    echo -e "from urllib.request import urlopen\nwith open('$2') as fi:\n with urlopen('$1') as rq:\n  fi.write(rq.read())" | python3
  else
    >&2 echo "One of 'wget', 'curl' or 'python3' is required to download files."
    >&2 echo "Install one of these then try again."
    return 1
  fi
}


##### NIX BUILDERS #####

# Download script wrapper to retrieve files from the source derivation this
# script was built with. Requires SOURCE_CACHE to be the host name for a
# Cachix-compatible HTTPS host (i.e. with endpoint /serve/xxx-hash/path)
_pull_source() {
  (
    cd "$USER_CACHE"
    _untar "sources/$1"
    mv "$1" "$2"
  ) || (
    cd "$USER_CACHE"
    _dl "https://$SOURCE_CACHE/serve/$SOURCE_DERIVATION/$1.tar.gz" "$1.tar.gz"
    gzip -d -c "$1.tar.gz" | tar x
    mv "$1" "$2"
    rm "$1.tar.gz"
  )
}

# Idem for static Nix binaries
_pull_nix_bin() {
  (
    cd "$USER_CACHE"
    _untar "$1"
    mv "$1" "$2"
  ) || (
    _dl "https://$SOURCE_CACHE/serve/$NIX_BINS_DERIVATION/$1" "$2"
  )
}

_find_or_build_openssl () {
  pkg-config libcrypto && return 0

  _pull_source "openssl" "$source_root/openssl"
  cd "$source_root/openssl"
  ./config && make

  cp ./libcrypto.so "$USER_CACHE/nix-lib/"

  export OPENSSL_LIBS="$USER_CACHE/nix-lib"
  export OPENSSL_CFLAGS="-I$source_root/openssl/include"
}

_find_or_build_autoconf () {
  libname="$1"
  varname="$2"

  pkg-config $libname && return 0

  _pull_source "$libname" "$source_root/$libname"
  cd "$source_root/$libname"
  ./configure && make

  cp ./$libpath/.libs/* "$USER_CACHE/nix-lib/"

  eval "export ${varname}_LIBS=$USER_CACHE/nix-lib"
  eval "export ${varname}_CFLAGS=-I$source_root/$libname/$incpfx/include"
}

_find_or_build_lowdown () {
  pkg-config lowdown && return 0

  _pull_source "lowdown" "$source_root/lowdown"
  cd "$source_root/lowdown"
  ./configure && make

  cp ./liblowdown.so "$USER_CACHE/nix-lib/"

  export LOWDOWN_LIBS="$USER_CACHE/nix-lib"
  export LOWDOWN_CFLAGS="-I$source_root/lowdown"
}

_find_or_build_nlohmann_json () {
  pkg-config nlohmann_json && return 0

  _pull_source "nlohmann_json" "$source_root/nlohmann_json"

  export NLOHMANN_JSON_LIBS="$source_root/nlohmann_json/single_include"
  export NLOHMANN_JSON_CFLAGS="-I$source_root/nlohmann_json/single_include"
}

_find_or_build_boost () {
  boost_libs=(atomic chrono container context system thread)
  for lb in ${boost_libs[@]}
  do
    [[ -f /usr/lib/libboost_$lb* ]] || \
    [[ -f /usr/local/lib/libboost_$lb* ]] || boost_not_found=1 && break
    [[ -f /usr/include/boost/$lb ]] || \
    [[ -f /usr/local/include/boost/$lb ]] || boost_not_found=1 && break
  done

  [[ $boost_not_found == 1 ]] || return 0

  _pull_source "boost" "$source_root/boost"
  cd "$source_root/boost"
  ./boostrap.sh && b2 --with-system --with-thread --with-context --with-container --with-chrono --static

  export BOOST_ROOT="$source_root/boost"
}

# Check that we have the required dependencies to build Nix locally, then
# do so.
_try_build_nix() {
  source_root="$REPO_ROOT/.nix-wrap/sources"

  _find_or_build_openssl
  _find_or_build_boost
  _find_or_build_nlohmann_json
  _find_or_build_lowdown
  libpath=              incpfx=c \
      _find_or_build_autoconf libbrotlicommon LIBBROTLI
  libpath=src/libsodium incpfx=src/libsodium \
      _find_or_build_autoconf libsodium       SODIUM
  libpath=src           incpfx= \
      _find_or_build_autoconf libeditline     EDITLINE

  _pull_source "nix" "$source_root/nix"

  cd "$source_root/nix"

  # Populate macOS SDK paths
  if [[ "$SYSTEM" =~ Darwin ]]
  then
    macos_sdk="$(xcode-select -p)/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk"
    [[ -d $macos_sdk ]] || _bail "Building Nix from source requires the Xcode macOS platform SDK."

    export LIBCURL_LIBS=$macos_sdk/usr/lib
    export LIBCURL_CFLAGS=$macos_sdk/usr/include
    export LIBARCHIVE_LIBS=$macos_sdk/usr/lib
    export LIBARCHIVE_CFLAGS=$macos_sdk/usr/include
    export OPENSSL_LIBS=$macos_sdk/usr/lib
    export OPENSSL_CFLAGS=$macos_sdk/usr/include
  fi

  ./configure --disable-seccomp-sandboxing \
              --disable-s3 \
              --disable-doc-gen \
              --disable-embedded-sandbox-shell \
              --disable-gc \
              --disable-cpuid \
  && make

  #TODO: determine binary output path and copy to nix-static
}

# Try a set of strategies to obtain a statically built Nix binary
_get_nix() {
  if [[ -v XDG_CACHE_HOME ]]
  then
    USER_CACHE="$XDG_CACHE_HOME"
  elif [[ $(uname -s) == Darwin ]]
  then
    USER_CACHE="$HOME/Library/Caches"
  else
    USER_CACHE="$HOME/.cache"
  fi

  # Check if the binary already exists
  [[ -f "$USER_CACHE/nix-static" ]] && return 0

  # Look in our sources for prebuilt binary
  _pull_nix_bin "nix-static.$SYSTEM" "$USER_CACHE/nix-static" && return 0

  # Build Nix locally from source
  _try_build_nix && return 0

  # Everything failed, bail out
  return 1
}


##### ENTRY POINT #####

# Load feature attributes of our resource tarball
eval "$(_untar features -O || _bail "The resource archive is missing or malformed.")"

# Running without a specified sources derivation is not supported, even if sources
# are shipped offline.
[[ -v SOURCE_CACHE ]] || [[ -v SOURCE_DERIVATION ]] || [[ -v NIX_BINS_DERIVATION ]] \
  || _bail "The features file in the resource archive is missing or malformed."

mkdir -p "$REPO_ROOT/.nix-wrap"

declare -a EXTRA_ARGS

declare -a CMDL_ARGS=("$@")

# Unpack builtin Nix channels for channel-oriented commands
if [[ "$0" =~ nix-(shell|build|env) ]]
then
  for chn in ${PINNED_CHANNELS[@]}
  do
    [[ -d "$REPO_ROOT/.nix-wrap/$chn" ]] \
      || (cd $REPO_ROOT/.nix-wrap; _untar "$chn" 2>/dev/null)
  done
  export NIX_PATH="$REPO_ROOT/.nix-wrap:$NIX_PATH"
fi

# Emulate nix-shell interpreter behavior
if [[ "$0" =~ "nix-shell" ]] && [[ -f "$1" ]] && ! [[ "$1" =~ .nix$ ]]
then
  {
    read
    IFS=' ' read -a nix_shell_args

    # There is a possibility that argv[1] is a Nix file.
    # Bail if there's no second line shebang.
    [[ "${nix_shell_args[0]}" =~ ^#! ]] || break

    nix_shell_args=("${nix_shell_args[@]:1}")
    [[ "${nix_shell_args[0]}" == "nix-shell" ]] && nix_shell_args=("${nix_shell_args[@]:1}")

    for i in "${!nix_shell_args[@]}"
    do
      [[ "${nix_shell_args[$i]}" == "-i" ]] && {
        nix_shell_args[$i]="--command"
        nix_shell_args[$((i+1))]="${nix_shell_args[$((i+1))]} $*"
      } && break
    done

    # Overwrite shell arguments with real interpreter
    CMDL_ARGS=("${nix_shell_args[@]}")
  } < "$1"
fi

# Apply experimental features if listed
[[ -v EXTRA_FEATURES ]] && EXTRA_ARGS+=("--extra-experimental-features" "$EXTRA_FEATURES")

# Apply extra substituters and their signing keys (e.g. cachix) if listed
[[ -v EXTRA_SUBSTITUTERS ]] && EXTRA_ARGS+=("--extra-substituters" "$EXTRA_SUBSTITUTERS") && nix_daemon_warn=1
[[ -v EXTRA_TRUSTED_PUBLIC_KEYS ]] && EXTRA_ARGS+=("--extra-trusted-public-keys" "$EXTRA_TRUSTED_PUBLIC_KEYS") && nix_daemon_warn=1

if [[ $nix_daemon_warn == 1 ]] && \
  pgrep nix-daemon >/dev/null 2>&1 && \
  ! grep "trusted-users\s*=.*$(whoami 2>/dev/null)" /etc/nix/nix.conf >/dev/null 2>&1
then
  >&2 echo "This nix wrapper script specifies additional binary caches,"
  >&2 echo "but you are running on a multi-user install as an untrusted user."
  >&2 echo "Cache substitution may not work until you add yourself to"
  >&2 echo "the trusted-users entry in /etc/nix/nix.conf."
fi

if which nix >&/dev/null
then
  exec -a "$0" nix "${EXTRA_ARGS[@]}" "${CMDL_ARGS[@]}"
else
  if _get_nix && chmod +x "$USER_CACHE/nix-static"
  then
    # This is required if the Nix binary was built locally.
    # It is highly unlikely that the user have static copies of all the
    # libraries required by Nix, so it's easier to build a shared binary.
    # After all, this binary isn't meant to leave its host machine.
    export LD_LIBRARY_PATH="$USER_CACHE/nix-lib:$LD_LIBRARY_PATH"

    if [[ "$SYSTEM" =~ Darwin ]]
    then
      # wow apple thanks
      user_save="$(whoami)"
      >&2 echo "Root privileges are required to mount the Nix store on macOS."
      >&2 echo "To avoid this issue in the future, install Nix on your system"
      >&2 echo "from https://nixos.org/download.html#nix-install-macos"
      >&2 echo "(or go bug Apple about their lack of namespace support)"
      mkdir -p "$HOME/Library/nix-wrap"
      sudo sh -c "[[ -d /nix ]] || { echo nix >> /etc/synthetic.conf; /System/Library/Filesystems/apfs.fs/Contents/MacOS/apfs.util -f; }; "
    else
      exec -a "$0" "$USER_CACHE/nix-static" \
        --store "$(readlink -e $HOME/.local/share/nix/root)" \
        "${EXTRA_ARGS[@]}" "${CMDL_ARGS[@]}"
    fi
  else
    >&2 echo "Failed to obtain Nix. Check your internet connection."
    exit 1
  fi
fi

# Prevent overrun into resource tarball
exit 1
cat <<DONOTPARSE

# The following archive data has been masked through alt screen buffer.
-----BEGIN ARCHIVE SECTION-----
