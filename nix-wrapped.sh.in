#!/usr/bin/env sh
# Nix-wrap (c) Karim Vergnes <me@thesola.io>
# Licensed under GNU GPLv2
# Required commands:
#  - sed
#  - tar (with gzip support)
#  - rm, mv, tail, uname, env, chmod, mkdir (coreutils)
#  - git
#  - kill
#  - one of wget, curl or python3 (with SSL support)
#  - sh with source and declare -a
# A C++ toolchain is also required for building Nix locally.

SYSTEM="$(uname -s).$(uname -m)"
REPO_ROOT="$(git rev-parse --show-toplevel)"
THIS_SCRIPT="$0"

# Output an error message to stderr then nuke ourselves
_bail() {
    >&2 echo $@
    >&2 echo "This script can be rebuilt using nix-wrap"
    kill -ABRT $$
}

# Pull a file or directory from the resource tarball linked into this
# script. Useful for semi-offline or completely offline operation.
_untar() {
    {
    sed -n '/^-----BEGIN ARCHIVE SECTION-----/,$p' "$THIS_SCRIPT" \
            | tail -n +2                                              \
            | gzip -d -c 2>/dev/null
    if ! ([[ $? == 2 ]] || [[ $? == 0 ]])
    then
        # The resource tarball is required since it contains the feature
        # attributes for this script. We bail out since there is no
        # situation where tar failing would bode well.
        _bail "Could not find or decompress resource archive."
    fi
    } | tar x "$@"
}

# Best-attempt script for downloading files. We first try wget, then cURL,
# then Python 3.
_dl() {
    if which wget >&/dev/null
    then
        wget "$1" -O"$2"
    elif which curl >&/dev/null
    then
        curl -L "$1" -o "$2"
    elif which python3 >&/dev/null
    then
        python3 <<EOF
from urllib.request import urlopen
with open('$2') as fi:
  with urlopen('$1') as rq:
    fi.write(rq.read())
EOF
    else
        >&2 echo "One of 'wget', 'curl' or 'python3' is required to download files."
        >&2 echo "Install one of these then try again."
        return 1
    fi
}

# Download script wrapper to retrieve files from the source derivation this
# script was built with. Requires SOURCE_CACHE to be the host name for a
# Cachix-compatible HTTPS host (i.e. with endpoint /serve/xxx-hash/path)
_pull_source() {
    {
        _untar "sources/$1" -C "$USER_CACHE"
        mv "$USER_CACHE/$1" "$2"
    } || {
        _dl "https://$SOURCE_CACHE/serve/$SOURCE_DERIVATION/$1" "$2"
    }
}

# Idem for static Nix binaries
_pull_nix_bin() {
    {
        _untar "$1" -C "$USER_CACHE"
        mv "$USER_CACHE/$1" "$2"
    } || {
        _dl "https://$SOURCE_CACHE/serve/$NIX_BINS_DERIVATION/$1" "$2"
    }
}

# Check that we have the required dependencies to build Nix locally, then
# do so.
_try_build_nix() {
    _pull_source "nix" "$REPO_ROOT/.nix-wrap/nix-source"

}

# Try a set of strategies to obtain a statically built Nix binary
_get_nix() {
    if [[ -v XDG_CACHE_HOME ]]
    then
        USER_CACHE="$XDG_CACHE_HOME"
    elif [[ $(uname -s) == Darwin ]]
    then
        USER_CACHE="$HOME/Library/Caches"
    else
        USER_CACHE="$HOME/.cache"
    fi

    # Check if the binary already exists
    [[ -f "$USER_CACHE/nix-static" ]] && return 0

    # Look in our sources for prebuilt binary
    _pull_nix_bin "nix-static.$SYSTEM" "$USER_CACHE/nix-static" && return 0

    # Build Nix locally from source
    _try_build_nix && return 0

    # Everything failed, bail out
    return 1
}

# Load feature attributes of our resource tarball
source <(_untar features -O || _bail "The resource archive is missing or malformed.")

# Running without a specified sources derivation is not supported, even if sources
# are shipped offline.
[[ -v SOURCE_CACHE ]] || [[ -v SOURCE_DERIVATION ]] || [[ -v NIX_BINS_DERIVATION ]] \
    || _bail "The features file in the resource archive is missing or malformed."

mkdir -p "$REPO_ROOT/.nix-wrap"

declare -a EXTRA_ARGS

# Unpack builtin Nix channels for channel-oriented commands
if [[ "$0" =~ "nix-(shell|build|env)" ]]
then
    for chn in ${PINNED_CHANNELS[@]}
    do
        _untar "$chn" -C "$REPO_ROOT/.nix-wrap"
        EXTRA_ARGS+=("--arg" "$chn" "$REPO_ROOT/.nix-wrap/$chn")
    done
fi

# Apply experimental features if listed
[[ -v EXTRA_FEATURES ]] && EXTRA_ARGS+=("--extra-experimental-features" "$EXTRA_FEATURES")

# Apply extra substituters and their signing keys (e.g. cachix) if listed
[[ -v EXTRA_SUBSTITUTERS ]] && EXTRA_ARGS+=("--extra-substituters" "$EXTRA_SUBSTITUTERS")
[[ -v EXTRA_TRUSTED_PUBLIC_KEYS ]] && EXTRA_ARGS+=("--extra-trusted-public-keys" "$EXTRA_TRUSTED_PUBLIC_KEYS")

if which nix >&/dev/null
then
    exec -a "$0" nix "${EXTRA_ARGS[@]}" "$@"
else
    if _get_nix && chmod +x "$USER_CACHE/nix-static"
    then
        # This is required if the Nix binary was built locally.
        # It is highly unlikely that the user have static copies of all the
        # libraries required by Nix, so it's easier to build a shared binary.
        # After all, this binary isn't meant to leave its host machine.
        LD_LIBRARY_PATH="$USER_CACHE/nix-lib:$LD_LIBRARY_PATH" \
        exec -a "$0" "$USER_CACHE/nix-static" "${EXTRA_ARGS[@]}" "$@"
    else
        >&2 echo "Failed to obtain Nix. Check your internet connection."
        exit 1
    fi
fi

# Prevent overrun into resource tarball
exit 1

# The following archive data has been masked through alt screen buffer.
-----BEGIN ARCHIVE SECTION-----
